<canvas
	id="threejs-canvas"
	class="fixed top-0 left-0 -z-10 h-full w-full opacity-0 transition-opacity duration-1000"
></canvas>

<script>
	const scheduleTask =
		window.requestIdleCallback || ((cb) => setTimeout(cb, 1))

	scheduleTask(async () => {
		const {
			initScene,
			addCubes,
			addSpheres,
			animateCubes,
			animateSpheres,
		} = await import("../helpers/threejs/index.ts")

		const canvas = document.getElementById(
			"threejs-canvas"
		) as HTMLCanvasElement
		const { scene, camera, renderer } = initScene(canvas)

		addCubes(scene, 300)
		addSpheres(scene, 1200)

		// Fade in the canvas after objects are added
		canvas.style.opacity = "0.5"

		// Update camera rotation and opacity based on scroll
		function handleScroll() {
			const scrollY = window.scrollY
			camera.rotation.y = scrollY * 0.0002

			// Increase opacity after scrolling past hero section
			if (scrollY > window.innerHeight) {
				const opacityProgress = Math.min(
					(scrollY - window.innerHeight) / window.innerHeight,
					1
				)
				canvas.style.opacity = String(0.5 + opacityProgress * 0.5) // 0.5 to 1
			} else {
				canvas.style.opacity = "0.5"
			}
		}

		window.addEventListener("scroll", handleScroll)

		// Add performance stats in development only
		let stats: any
		if (import.meta.env.DEV) {
			const Stats = (await import("stats.js")).default
			stats = new Stats()
			stats.showPanel(0) // 0: fps, 1: ms, 2: mb
			document.body.appendChild(stats.dom)
		}

		renderer.setAnimationLoop(animate)

		let lastTime = 0
		const targetFPS = 30
		const frameInterval = 1000 / targetFPS

		function animate(time: number) {
			if (time - lastTime < frameInterval) return
			lastTime = time

			if (stats) stats.begin()

			animateCubes()
			animateSpheres(time)
			renderer.render(scene, camera)

			if (stats) stats.end()
		}
	})
</script>
